import { createSpinner } from "nanospinner";
import { loadConfig } from "../utils/configLoader";
import { logger } from "../utils/logger";
import {
  analyzeProject,
  ProjectStats,
  AnalysisOptions,
} from "../utils/projectAnalyzer";

export const analyzeProjectCommand = async (options: AnalysisOptions) => {
  const spinner = createSpinner("Analyzing project...").start();

  try {
    const config = loadConfig();

    // Analiz yap
    const stats = await analyzeProject(config, options);

    if (options.json) {
      // JSON formatında çıktı - HTML ile tutarlı hale getir
      const enhancedStats = {
        ...stats,
        metadata: {
          generatedAt: new Date().toISOString(),
          tool: "Kedy CLI",
          version: "1.0.0",
          disclaimer:
            "This report was generated by Kedy CLI tool. Analysis results may contain errors or inaccuracies. Use at your own risk.",
        },
        summary: {
          projectOverview: {
            totalFiles: stats.totalFiles,
            totalLines: stats.totalLines,
            totalSizeKB: (stats.totalSize / 1024).toFixed(2),
          },
          fileDistribution: {
            screens: stats.screens.length,
            components: stats.components.length,
            hooks: stats.hooks.length,
            utils: stats.utils.length,
            others: stats.others.length,
          },
          codeQuality: {
            highComplexityComponents: stats.components.filter(
              (f) => f.complexity > 10
            ).length,
            largeScreens: stats.screens.filter((f) => f.lines > 200).length,
            unusedCodePercentage: (
              (stats.unusedFiles.length / stats.totalFiles) *
              100
            ).toFixed(1),
          },
        },
        projectStructure: generateProjectStructure(stats),
      };

      console.log(JSON.stringify(enhancedStats, null, 2));
      spinner.success({ text: "Project analysis completed!" });
      return;
    }

    if (options.html) {
      // HTML raporu oluştur (basit versiyon)
      generateHTMLReport(stats);
      spinner.success({ text: "HTML report generated!" });
      return;
    }

    // Konsol raporu
    displayConsoleReport(stats, options);

    spinner.success({ text: "Project analysis completed!" });
  } catch (error: any) {
    spinner.error({ text: `Failed to analyze project: ${error.message}` });
    logger.error(error);
  }
};

// Konsol raporu göster
const displayConsoleReport = (
  stats: ProjectStats,
  options: AnalysisOptions
) => {
  console.log("\n📊 Project Analysis Report");
  console.log("=".repeat(50));

  // Proje genel bakış
  console.log("\n🏗️  Project Overview:");
  console.log(`   📁 Total files: ${stats.totalFiles}`);
  console.log(`   📝 Total lines: ${stats.totalLines.toLocaleString()}`);
  console.log(`   💾 Total size: ${(stats.totalSize / 1024).toFixed(2)} KB`);

  // Kategorilere göre dağılım
  console.log("\n📂 File Distribution:");
  console.log(`   📱 Screens: ${stats.screens.length}`);
  console.log(`   🧩 Components: ${stats.components.length}`);
  console.log(`   🪝 Hooks: ${stats.hooks.length}`);
  console.log(`   🛠️  Utils: ${stats.utils.length}`);
  console.log(`   📄 Others: ${stats.others.length}`);

  if (options.detailed) {
    // Detaylı screen analizi
    if (stats.screens.length > 0) {
      console.log("\n📱 Screen Analysis:");
      const sortedScreens = [...stats.screens].sort(
        (a, b) => b.lines - a.lines
      );
      sortedScreens.slice(0, 5).forEach((screen) => {
        const sizeKB = (screen.size / 1024).toFixed(2);
        console.log(
          `   📄 ${screen.relativePath} (${screen.lines} lines, ${sizeKB} KB, complexity: ${screen.complexity})`
        );
      });
    }

    // Detaylı component analizi
    if (stats.components.length > 0) {
      console.log("\n🧩 Component Analysis:");
      const sortedComponents = [...stats.components].sort(
        (a, b) => b.complexity - a.complexity
      );
      sortedComponents.slice(0, 5).forEach((component) => {
        const sizeKB = (component.size / 1024).toFixed(2);
        console.log(
          `   📄 ${component.relativePath} (${component.lines} lines, ${sizeKB} KB, complexity: ${component.complexity})`
        );
      });
    }

    // Kullanılmayan dosyalar
    if (stats.unusedFiles.length > 0) {
      console.log("\n🗑️  Unused Files:");
      stats.unusedFiles.forEach((file) => {
        console.log(`   📄 ${file}`);
      });
    }
  }

  // Code quality analizi
  console.log("\n🛠️  Code Quality:");
  const highComplexityComponents = stats.components.filter(
    (f) => f.complexity > 10
  );
  const largeScreens = stats.screens.filter((f) => f.lines > 200);
  const unusedPercentage = (stats.unusedFiles.length / stats.totalFiles) * 100;

  console.log(
    `   ⚠️  High complexity components: ${highComplexityComponents.length}`
  );
  console.log(`   📏 Large screens (>200 lines): ${largeScreens.length}`);
  console.log(`   🗑️  Unused code: ${unusedPercentage.toFixed(1)}%`);

  // Öneriler
  if (stats.recommendations.length > 0) {
    console.log("\n💡 Recommendations:");
    stats.recommendations.forEach((rec, index) => {
      console.log(`   ${index + 1}. ${rec}`);
    });
  }

  // Architecture Analizi
  if (stats.architecture) {
    console.log("\n🏗️ Architecture Analysis:");
    console.log(
      `   📁 Folder Structure: ${stats.architecture.folderStructure.score}/100`
    );
    console.log(
      `   📝 Naming Conventions: ${stats.architecture.namingConventions.score}/100`
    );
    console.log(
      `   🧩 Component Hierarchy: Max depth ${stats.architecture.componentHierarchy.maxDepth}`
    );
    console.log(
      `   🔄 State Management: ${
        stats.architecture.stateManagement.patterns.join(", ") ||
        "None detected"
      }`
    );

    if (stats.architecture.folderStructure.issues.length > 0) {
      console.log("   ⚠️ Folder Issues:");
      stats.architecture.folderStructure.issues
        .slice(0, 3)
        .forEach((issue) => console.log(`      • ${issue}`));
    }
  }

  // Testing Analizi
  if (stats.testing) {
    console.log("\n🧪 Testing Analysis:");
    console.log(
      `   📊 Coverage: ${stats.testing.coverage.coveragePercentage}% (${stats.testing.coverage.testedFiles}/${stats.testing.coverage.totalFiles} files)`
    );
    console.log(`   🎯 Test Quality: ${stats.testing.testQuality.score}/100`);
    console.log(
      `   🛠️ Frameworks: ${
        stats.testing.testPatterns.frameworks.join(", ") || "None detected"
      }`
    );

    if (stats.testing.coverage.missingTests.length > 0) {
      console.log("   ❌ Missing Tests:");
      stats.testing.coverage.missingTests
        .slice(0, 3)
        .forEach((test) => console.log(`      • ${test}`));
    }
  }

  // Security Analizi
  if (stats.security) {
    console.log("\n🔒 Security Analysis:");
    console.log(
      `   📦 Vulnerable Packages: ${stats.security.dependencies.vulnerablePackages.length}`
    );
    console.log(
      `   🔑 Hardcoded Secrets: ${stats.security.codeSecurity.hardcodedSecrets.length}`
    );
    console.log(
      `   🌐 API Endpoints: ${stats.security.apiSecurity.endpoints.length}`
    );
    console.log(
      `   ✅ Input Validation: ${stats.security.inputValidation.missingValidation.length} missing`
    );

    if (stats.security.codeSecurity.hardcodedSecrets.length > 0) {
      console.log("   ⚠️ Security Issues:");
      stats.security.codeSecurity.hardcodedSecrets
        .slice(0, 2)
        .forEach((secret) => console.log(`      • ${secret}`));
    }
  }
};

// HTML raporu oluştur
const generateHTMLReport = (stats: ProjectStats) => {
  const html = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Analysis Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1 { color: #333; text-align: center; }
        .section { margin: 20px 0; padding: 15px; border-left: 4px solid #007AFF; background: #f8f9fa; }
        .metric { display: inline-block; margin: 10px; padding: 10px; background: #e9ecef; border-radius: 4px; }
        .score { font-size: 24px; font-weight: bold; }
        .excellent { color: #28a745; }
        .good { color: #ffc107; }
        .fair { color: #fd7e14; }
        .poor { color: #dc3545; }
        .file-list { list-style: none; padding: 0; }
        .file-list li { padding: 5px 0; border-bottom: 1px solid #eee; }
        .recommendations { background: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 4px; }
        .analysis-section { margin: 25px 0; padding: 20px; border-left: 4px solid #28a745; background: #f8fff8; }
        .analysis-section h3 { color: #28a745; margin-top: 0; }
        .sub-metric { margin: 8px 0; padding: 8px; background: #e8f5e8; border-radius: 4px; }
        .warning { color: #dc3545; }
        .success { color: #28a745; }
        .info { color: #007AFF; }
        .error-section { margin: 15px 0; padding: 12px; background: #fff5f5; border-left: 4px solid #dc3545; border-radius: 4px; }
        .warning-section { margin: 15px 0; padding: 12px; background: #fffbf0; border-left: 4px solid #ffc107; border-radius: 4px; }
        .info-section { margin: 15px 0; padding: 12px; background: #f0f8ff; border-left: 4px solid #007AFF; border-radius: 4px; }
        .error-title { color: #dc3545; font-weight: bold; margin-bottom: 8px; }
        .warning-title { color: #ffc107; font-weight: bold; margin-bottom: 8px; }
        .info-title { color: #007AFF; font-weight: bold; margin-bottom: 8px; }
        .tree-structure { font-family: 'Courier New', monospace; font-size: 15px; line-height: 1.6; background: #f8f9fa; padding: 15px; border-radius: 6px; border: 1px solid #e9ecef; }
        .tree-folder { color: #007AFF; font-weight: bold; margin: 8px 0 4px 0; font-size: 16px; }
        .tree-file { color: #333; margin: 2px 0; font-weight: 600; }
        .tree-screen { color: #28a745; margin: 2px 0; font-weight: 600; }
        .tree-component { color: #ffc107; margin: 2px 0; font-weight: 600; }
        .tree-hook { color: #fd7e14; margin: 2px 0; font-weight: 600; }
        .tree-util { color: #6f42c1; margin: 2px 0; font-weight: 600; }
        .tree-unused { color: #dc3545; margin: 2px 0; font-weight: 600; }
    </style>
</head>
<body>
    <div class="container">
        <h1>📊 Project Analysis Report</h1>
        
        <!-- Project Overview -->
        <div class="analysis-section">
            <h3>🏗️ Project Overview</h3>
            <div class="sub-metric">📁 Total files: <strong>${
              stats.totalFiles
            }</strong></div>
            <div class="sub-metric">📝 Total lines: <strong>${stats.totalLines.toLocaleString()}</strong></div>
            <div class="sub-metric">💾 Total size: <strong>${(
              stats.totalSize / 1024
            ).toFixed(2)} KB</strong></div>
        </div>
        
        <!-- File Distribution -->
        <div class="analysis-section">
            <h3>📂 File Distribution</h3>
            <div class="sub-metric">📱 Screens: <strong>${
              stats.screens.length
            }</strong></div>
            <div class="sub-metric">🧩 Components: <strong>${
              stats.components.length
            }</strong></div>
            <div class="sub-metric">🪝 Hooks: <strong>${
              stats.hooks.length
            }</strong></div>
            <div class="sub-metric">🛠️ Utils: <strong>${
              stats.utils.length
            }</strong></div>
            <div class="sub-metric">📄 Others: <strong>${
              stats.others.length
            }</strong></div>
            
            <div class="info-section">
                <div class="info-title">🌳 Project Structure:</div>
                <div class="tree-structure">${generateProjectTree(stats)}</div>
            </div>
        </div>
        
        <!-- Code Quality -->
        <div class="analysis-section">
            <h3>🛠️ Code Quality</h3>
            <div class="sub-metric">⚠️ High complexity components: <strong>${
              stats.components.filter((f) => f.complexity > 10).length
            }</strong></div>
            <div class="sub-metric">📏 Large screens (>200 lines): <strong>${
              stats.screens.filter((f) => f.lines > 200).length
            }</strong></div>
            <div class="sub-metric">🗑️ Unused code: <strong>${(
              (stats.unusedFiles.length / stats.totalFiles) *
              100
            ).toFixed(1)}%</strong></div>
            ${
              stats.components.filter((f) => f.complexity > 10).length > 0
                ? `
            <div class="warning-section">
                <div class="warning-title">⚠️ High Complexity Components:</div>
                <ul class="file-list">${stats.components
                  .filter((f) => f.complexity > 10)
                  .map(
                    (comp) =>
                      `<li>• ${comp.relativePath} (complexity: ${comp.complexity})</li>`
                  )
                  .join("")}</ul>
            </div>`
                : ""
            }
            ${
              stats.screens.filter((f) => f.lines > 200).length > 0
                ? `
            <div class="warning-section">
                <div class="warning-title">⚠️ Large Screens:</div>
                <ul class="file-list">${stats.screens
                  .filter((f) => f.lines > 200)
                  .map(
                    (screen) =>
                      `<li>• ${screen.relativePath} (${screen.lines} lines)</li>`
                  )
                  .join("")}</ul>
            </div>`
                : ""
            }
        </div>
        

        
                
        
        <!-- Architecture Analysis -->
        <div class="analysis-section">
            <h3>🏗️ Architecture Analysis</h3>
            <div class="sub-metric">📁 Folder Structure: <strong>${
              stats.architecture?.folderStructure?.score || 0
            }/100</strong></div>
            <div class="sub-metric">📝 Naming Conventions: <strong>${
              stats.architecture?.namingConventions?.score || 0
            }/100</strong></div>
            <div class="sub-metric">🧩 Component Hierarchy: Max depth <strong>${
              stats.architecture?.componentHierarchy?.maxDepth || 0
            }</strong></div>
            <div class="sub-metric">🔄 State Management: <strong>${
              stats.architecture?.stateManagement?.patterns?.join(", ") ||
              "None detected"
            }</strong></div>
            ${
              stats.architecture?.folderStructure?.issues &&
              stats.architecture.folderStructure.issues.length > 0
                ? `
            <div class="warning-section">
                <div class="warning-title">⚠️ Folder Structure Issues:</div>
                <ul class="file-list">${stats.architecture.folderStructure.issues
                  .map((issue: string) => `<li>• ${issue}</li>`)
                  .join("")}</ul>
            </div>`
                : ""
            }
            ${
              stats.architecture?.namingConventions?.violations &&
              stats.architecture.namingConventions.violations.length > 0
                ? `
            <div class="warning-section">
                <div class="warning-title">⚠️ Naming Convention Violations:</div>
                <ul class="file-list">${stats.architecture.namingConventions.violations
                  .map((violation: string) => `<li>• ${violation}</li>`)
                  .join("")}</ul>
            </div>`
                : ""
            }
            ${
              stats.architecture?.folderStructure?.recommendations &&
              stats.architecture.folderStructure.recommendations.length > 0
                ? `
            <div class="recommendations">
                <h4>Architecture Recommendations:</h4>
                <ul>${stats.architecture.folderStructure.recommendations
                  .map((rec: string) => `<li>${rec}</li>`)
                  .join("")}</ul>
            </div>`
                : ""
            }
        </div>
        
                <!-- Testing Analysis -->
        <div class="analysis-section">
            <h3>🧪 Testing Analysis</h3>
            <div class="sub-metric">📊 Coverage: <strong>${
              stats.testing?.coverage?.coveragePercentage || 0
            }%</strong> (${stats.testing?.coverage?.testedFiles || 0}/${
    stats.testing?.coverage?.totalFiles || 0
  } files)</div>
            <div class="sub-metric">🎯 Test Quality: <strong>${
              stats.testing?.testQuality?.score || 0
            }/100</strong></div>
            <div class="sub-metric">🛠️ Frameworks: <strong>${
              stats.testing?.testPatterns?.frameworks?.join(", ") ||
              "None detected"
            }</strong></div>
            ${
              stats.testing?.coverage?.missingTests &&
              stats.testing.coverage.missingTests.length > 0
                ? `
            <div class="warning-section">
                <div class="warning-title">⚠️ Missing Tests:</div>
                <ul class="file-list">${stats.testing.coverage.missingTests
                  .map((test: string) => `<li>• ${test}</li>`)
                  .join("")}</ul>
            </div>`
                : ""
            }
            ${
              stats.testing?.coverage?.recommendations &&
              stats.testing.coverage.recommendations.length > 0
                ? `
            <div class="recommendations">
                <h4>Testing Recommendations:</h4>
                <ul>${stats.testing.coverage.recommendations
                  .map((rec: string) => `<li>${rec}</li>`)
                  .join("")}</ul>
            </div>`
                : ""
            }
        </div>
        
        <!-- Security Analysis -->
        <div class="analysis-section">
            <h3>🔒 Security Analysis</h3>
            <div class="sub-metric">📦 Vulnerable Packages: <strong>${
              stats.security?.dependencies?.vulnerablePackages?.length || 0
            }</strong></div>
            <div class="sub-metric">🔑 Hardcoded Secrets: <strong>${
              stats.security?.codeSecurity?.hardcodedSecrets?.length || 0
            }</strong></div>
            <div class="sub-metric">🌐 API Endpoints: <strong>${
              stats.security?.apiSecurity?.endpoints?.length || 0
            }</strong></div>
            <div class="sub-metric">✅ Input Validation: <strong>${
              stats.security?.inputValidation?.missingValidation?.length || 0
            }</strong> missing</div>
            ${
              stats.security?.dependencies?.vulnerablePackages &&
              stats.security.dependencies.vulnerablePackages.length > 0
                ? `
            <div class="error-section">
                <div class="error-title">❌ Vulnerable Packages:</div>
                <ul class="file-list">${stats.security.dependencies.vulnerablePackages
                  .map((pkg: string) => `<li>• ${pkg}</li>`)
                  .join("")}</ul>
            </div>`
                : ""
            }
            ${
              stats.security?.codeSecurity?.hardcodedSecrets &&
              stats.security.codeSecurity.hardcodedSecrets.length > 0
                ? `
            <div class="error-section">
                <div class="error-title">❌ Hardcoded Secrets:</div>
                <ul class="file-list">${stats.security.codeSecurity.hardcodedSecrets
                  .map((secret: string) => `<li>• ${secret}</li>`)
                  .join("")}</ul>
            </div>`
                : ""
            }
            ${
              stats.security?.apiSecurity?.issues &&
              stats.security.apiSecurity.issues.length > 0
                ? `
            <div class="error-section">
                <div class="error-title">❌ API Security Issues:</div>
                <ul class="file-list">${stats.security.apiSecurity.issues
                  .map((issue: string) => `<li>• ${issue}</li>`)
                  .join("")}</ul>
            </div>`
                : ""
            }
            ${
              stats.security?.dependencies?.recommendations &&
              stats.security.dependencies.recommendations.length > 0
                ? `
            <div class="recommendations">
                <h4>Security Recommendations:</h4>
                <ul>${stats.security.dependencies.recommendations
                  .map((rec: string) => `<li>${rec}</li>`)
                  .join("")}</ul>
            </div>`
                : ""
            }
        </div>
        

        
        ${
          stats.recommendations.length > 0
            ? `
        <!-- General Recommendations -->
        <div class="analysis-section">
            <h3>💡 General Recommendations</h3>
            <ul class="file-list">${stats.recommendations
              .map((rec) => `<li>• ${rec}</li>`)
              .join("")}</ul>
        </div>`
            : ""
        }
        
        ${
          stats.unusedFiles.length > 0
            ? `
        <!-- Unused Files -->
        <div class="info-section">
            <div class="info-title">🗑️ Unused Files</div>
            <ul class="file-list">${stats.unusedFiles
              .map((file) => `<li>📄 ${file}</li>`)
              .join("")}</ul>
        </div>`
            : ""
        }
        
        <!-- Disclaimer -->
        <div style="margin-top: 40px; padding: 20px; background: #f8f9fa; border-top: 2px solid #e9ecef; text-align: center; color: #6c757d; font-size: 12px; font-style: italic;">
            <p>⚠️ This report was generated by Kedy CLI tool. Analysis results may contain errors or inaccuracies. Use at your own risk.</p>
            <p>📄 Generated on: ${new Date().toLocaleString()}</p>
        </div>
    </div>
</body>
</html>`;

  const fs = require("fs");
  fs.writeFileSync("project-analysis-report.html", html);
  console.log("📄 HTML report saved as: project-analysis-report.html");
};

// Skor sınıfını belirle
const getScoreClass = (score: number): string => {
  if (score >= 80) return "excellent";
  if (score >= 60) return "good";
  if (score >= 40) return "fair";
  return "poor";
};

// Skor açıklamasını belirle
const getScoreDescription = (score: number): string => {
  if (score >= 80) return "Your project is well-optimized!";
  if (score >= 60) return "Some improvements can be made.";
  if (score >= 40) return "Consider implementing the recommendations.";
  return "Significant improvements needed.";
};

// JSON için proje yapısı oluştur
const generateProjectStructure = (stats: ProjectStats): any => {
  const allFiles = [
    ...stats.screens,
    ...stats.components,
    ...stats.hooks,
    ...stats.utils,
    ...stats.others,
  ];

  // Dosyaları klasörlere göre grupla
  const folderStructure: { [key: string]: any[] } = {};

  allFiles.forEach((file) => {
    const pathParts = file.relativePath.split("/");
    const folder = pathParts.slice(0, -1).join("/");
    const fileName = pathParts[pathParts.length - 1];

    if (!folderStructure[folder]) {
      folderStructure[folder] = [];
    }

    folderStructure[folder].push({
      name: fileName,
      type: file.type,
      isUnused: stats.unusedFiles.includes(file.relativePath),
      size: file.size,
      lines: file.lines,
      complexity: file.complexity,
      relativePath: file.relativePath,
    });
  });

  // Klasörleri sırala ve JSON formatında döndür
  const sortedFolders = Object.keys(folderStructure).sort();
  const structure: { [key: string]: any[] } = {};

  sortedFolders.forEach((folder) => {
    const sortedFiles = folderStructure[folder].sort((a, b) =>
      a.name.localeCompare(b.name)
    );
    structure[folder] = sortedFiles;
  });

  return structure;
};

// HTML için proje ağacı oluştur
const generateProjectTree = (stats: ProjectStats): string => {
  const allFiles = [
    ...stats.screens,
    ...stats.components,
    ...stats.hooks,
    ...stats.utils,
    ...stats.others,
  ];

  // Dosyaları klasörlere göre grupla
  const folderStructure: { [key: string]: any[] } = {};

  allFiles.forEach((file) => {
    const pathParts = file.relativePath.split("/");
    const folder = pathParts.slice(0, -1).join("/");
    const fileName = pathParts[pathParts.length - 1];

    if (!folderStructure[folder]) {
      folderStructure[folder] = [];
    }

    folderStructure[folder].push({
      name: fileName,
      type: file.type,
      isUnused: stats.unusedFiles.includes(file.relativePath),
    });
  });

  let tree = "";

  // Ana klasörleri sırala
  const sortedFolders = Object.keys(folderStructure).sort();

  sortedFolders.forEach((folder, folderIndex) => {
    // Klasör adını göster
    tree += `<div class="tree-folder">📁 ${folder}/</div>`;

    // Klasör içindeki dosyaları sırala
    const sortedFiles = folderStructure[folder].sort((a, b) =>
      a.name.localeCompare(b.name)
    );

    sortedFiles.forEach((file, fileIndex) => {
      const isLastFile = fileIndex === sortedFiles.length - 1;

      // Tree çizgileri - daha basit ve temiz
      const connector = isLastFile ? "└── " : "├── ";

      // Dosya türüne göre icon ve renk sınıfı
      let icon = "📄";
      let colorClass = "tree-file";

      switch (file.type) {
        case "screen":
          icon = "📱";
          colorClass = "tree-screen";
          break;
        case "component":
          icon = "🧩";
          colorClass = "tree-component";
          break;
        case "hook":
          icon = "🪝";
          colorClass = "tree-hook";
          break;
        case "util":
          icon = "🛠️";
          colorClass = "tree-util";
          break;
        default:
          icon = "📄";
          colorClass = "tree-file";
      }

      // Unused dosyalar için sadece renk değişikliği (üstü çizili değil)
      if (file.isUnused) {
        colorClass = "tree-unused";
      }

      tree += `<div class="${colorClass}">    ${connector}${icon} ${file.name}</div>`;
    });
  });

  return tree;
};
